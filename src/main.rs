use std::fs;

mod common;
mod grammar;
mod runtime;

use clap::Parser;

use crate::{
    common::OpacaError,
    grammar::{
        lexer::{Lexer, Token},
        parser,
    },
};

type OpacaParser = parser::Parser;

#[derive(clap::Parser, Debug)]
#[command(about, long_about = None)]
struct Args {
    /// Print the current Opaca version.
    #[arg(short, long, default_value_t = false)]
    version: bool,

    /// Show the tokens generated by the lexer.
    #[arg(short, long, default_value_t = false)]
    tokens: bool,

    /// Show the nodes generated by the parser.
    #[arg(short, long, default_value_t = false)]
    nodes: bool,

    rem: Vec<String>,
}

fn main() -> Result<(), OpacaError> {
    let args = Args::parse();

    if args.version {
        println!("Opaca version {}", runtime::OPACA_VERSION);
        return Ok(());
    }

    if args.rem.len() == 0 {
        return Err(OpacaError::from(String::from("no input files")));
    }

    let mut all_tokens: Vec<Token> = Vec::new();

    for path in &args.rem {
        let content = match fs::read_to_string(path) {
            Ok(v) => Ok(v),
            Err(e) => Err(OpacaError::from(e)),
        }?;

        let mut lexer = Lexer::new(path.clone(), &content);

        let tokens = lexer.lex()?;

        for t in tokens {
            all_tokens.push(t);
        }
    }

    if args.tokens {
        println!("tokens:");

        for (i, token) in all_tokens.iter().enumerate() {
            println!(" {}: {}", i, token);
        }
    }

    let mut parser = OpacaParser::new(all_tokens);

    let nodes = parser.parse()?;

    if args.nodes {
        println!("nodes:");

        for (i, node) in nodes.iter().enumerate() {
            println!("{}:\n{}\n", i, node);
        }
    }

    Ok(())
}
