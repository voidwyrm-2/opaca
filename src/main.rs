use std::{collections::HashMap, fs, process::exit};

mod common;
mod grammar;
mod runtime;

use clap::Parser;

use crate::{
    common::OpacaError,
    grammar::{
        lexer::{Lexer, Token},
        parser::{self, Node},
    },
    runtime::{interpretation, module::Module},
};

type OpacaParser = parser::Parser;

#[derive(clap::Parser, Debug)]
#[command(about, long_about = None)]
struct Args {
    /// Print the current Opaca version.
    #[arg(short, long, default_value_t = false)]
    version: bool,

    /// Show the tokens generated by the lexer.
    #[arg(short, long, default_value_t = false)]
    tokens: bool,

    /// Show the nodes generated by the parser.
    #[arg(short, long, default_value_t = false)]
    nodes: bool,

    /// The backend to use
    #[arg(short, long, default_value_t = ("interpreter").to_owned())]
    backend: String,

    rem: Vec<String>,
}

fn main() -> Result<(), OpacaError> {
    let args = Args::parse();

    if args.version {
        println!("Opaca version {}", runtime::OPACA_VERSION);
        return Ok(());
    }

    if args.rem.len() == 0 {
        return Err(OpacaError::from(String::from("no input files")));
    }

    let mut all_tokens: Vec<Token> = Vec::new();

    for path in &args.rem {
        let content = match fs::read_to_string(path) {
            Ok(v) => Ok(v),
            Err(e) => Err(OpacaError::from(e)),
        }?;

        let mut lexer = Lexer::new(path.clone(), &content);

        let tokens = lexer.lex()?;

        for t in tokens {
            all_tokens.push(t);
        }
    }

    if args.tokens {
        println!("tokens:");

        for (i, token) in all_tokens.iter().enumerate() {
            println!(" {}: {}", i, token);
        }
    }

    let mut parser = OpacaParser::new(all_tokens);

    let nodes = parser.parse()?;

    if args.nodes {
        println!("nodes:");

        for (i, node) in nodes.iter().enumerate() {
            println!("{}:\n{}\n", i, node);
        }
    }

    let mut modules: HashMap<String, Module> = HashMap::new();

    for node in nodes {
        let (name, module) = interpretation::eval_module(node.clone())?;

        if modules.contains_key(&name) {
            if let Node::Module { name, .. } = node {
                return Err(token_opacaerr!(
                    name,
                    "module '{}' already exists",
                    name.get_typ().get_string()
                ));
            }
        }

        modules.insert(name, module);
    }

    if let Some(main_module) = modules.get(&String::from("Main")) {
        let main_fun = main_module.get_symbol(&(String::from("main"), 0))?;
    }

    Ok(())
}
